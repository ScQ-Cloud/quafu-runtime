import json
from typing import Optional
import requests


class RuntimeClient:
    """Class for accessing Quafu runtime server."""

    def __init__(self,
                 token: str,
                 url: str
                 ):
        """RuntimeClient constructor

        Args:
            token: user's api_token.
            url: Runtime client api url.
        """
        self._token = token
        self._url = url + "/runtime"
        self._session = requests.session()
        self.headers = {'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8', 'api_token': self._token}

    def program_upload(self,
                       program_data: str,
                       name: str,
                       backend: str,
                       group: str = None,
                       max_execution_time: Optional[int] = None,
                       description: Optional[str] = None,
                       is_public: bool = False,
                       ):
        """Upload a new program.

        Args:
            name: Name of the program.
            program_data: Program data (code of program).
            backend: backend used by task.
            description: Program description.
            group: Group user belong.
            max_execution_time: Maximum execution time.
            is_public: Whether the program should be public.

        Returns:
            Server response in json. Contains program id generated by server if upload successfully.
        """
        url = self.get_url("programs_upload")
        payload = {
            "name": name,
            "data": program_data,
            "backend": backend,
            "group": group,
            "cost": max_execution_time,
            "description": description,
            "is_public": 1 if is_public is True else 0,
        }
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def program_update(
            self,
            program_id: str,
            program_data: str = None,
            name: str = None,
            description: str = None,
            max_execution_time: int = None,
            is_public: bool = None,
            backend: str = None,
            group: str = None
    ):
        """Update an existed program.

        Args:
            program_id: Program ID.
            program_data: Program data (code of program).
            name: Name of the program.
            backend: backend used by task.
            description: Program description.
            group: Group user belong.
            max_execution_time: Maximum execution time.
            is_public: Whether the program should be public.

        Returns:
            Server response in json. Contains all msg of the updated program.
        """
        # update data
        payload = {"program_id": program_id}
        url = self.get_url("program_update")
        if program_data:
            payload["data"] = program_data
        # update metadata
        if any([name, description, max_execution_time, is_public, backend, group]):
            if name:
                payload["name"] = name
            if description:
                payload["description"] = description
            if max_execution_time:
                payload["cost"] = max_execution_time
            if is_public:
                payload["is_public"] = 1 if is_public is True else 0,
            if group:
                payload["group"] = group
            if backend:
                payload["backend"] = backend
        # print('program_id:', payload['program_id'])
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def program_delete(self, program_id: str):
        """Delete an existed program.

        Args:
            program_id: Program ID.

        Return:
            'success' if delete program successfully.
        """
        url = self.get_url("program_delete")
        res = self._session.delete(url, headers=self.headers, params={'program_id': program_id})
        if res.status_code == 200:
            res = res.json()
            return res['status']
        else:
            return res.status_code

    def program_run(self,
                    program_id: str = None,
                    name: str = None,
                    backend: str = None,
                    params: dict = None):
        """Run a program on the runtime server.

        Args:
            program_id: Program ID.
            name: Program name.
            backend: Name of the backend to run the program.
            params: Parameters to use.

        Returns:
            Json response. Contains msg about job created by server if run successfully.

        """
        url = self.get_url("programs_run_deploy")
        payload = {
            "program_id": program_id,
            "program_name": name
        }
        if backend is not None:
            payload['backend'] = backend
        if params is not None:
            payload['params'] = params
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def get_programs(self, limit: int = 0, skip: int = 0):
        """Return a list of metadata of runtime programs.

        Args:
            limit: The number of programs to return.
            skip: The number of programs to skip.

        Returns:
            A list of metadata of runtime programs.
        """
        url = self.get_url("programs")
        payload = {
            "limit": limit,
            "offset": skip
        }
        res = self._session.get(url, headers=self.headers, params=payload)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def program_get(self,
                    program_id: str = None,
                    name: str = None):
        """Get an existed program.
        Args:
            program_id: Program ID.
            name: Program name.

        Returns:
            Program's all msg.
        """
        url = self.get_url("program")
        payload = {
            "program_id": program_id,
            "name": name
        }
        res = self._session.get(url, headers=self.headers, params=payload)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def program_validate(self):
        """Before upload to server, check the program.
        """
        pass

    def job_result(self,
                   job_id: str,
                   wait: bool = False):
        """Try to get result of a job.

        Args:
            job_id: Program job ID.
            wait: Weather waiting for result. If set to 'False', return immediately.

        Returns:
            Job result.
        """
        if wait:
            url = self.get_url("get_result_wait")
        else:
            url = self.get_url("get_result_nowait")
        payload = {
            "job_id": job_id,
        }
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def job_result_nowait(self,
                          job_id: str):
        """Try to get result.

        Args:
            job_id: Program job ID.

        Returns:
            Job result if job's done.
        """
        url = self.get_url("get_result_nowait")
        payload = {
            "job_id": job_id,
        }
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def job_cancel(self, job_id):
        """Cancel a job.

        Args:
            job_id: Program job ID.

        Returns:
            Json response.
        """
        url = self.get_url("job_cancel")
        payload = {
            "job_id": job_id,
        }
        data = json.dumps(payload)
        res = self._session.post(url, headers=self.headers, data=data)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def job_status(self, job_id: str):
        """Get job status.

        Args:
            job_id: Program job ID.

        Returns:
            Json response.
        """
        url = self.get_url("job_status")
        payload = {
            "job_id": job_id,
        }
        res = self._session.get(url, headers=self.headers, params=payload)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def job_logs(self, job_id):
        """Get the job logs.

        Args:
            job_id: Program job ID.

        Returns:
            Job logs.
        """
        url = self.get_url("job_logs")
        payload = {
            "job_id": job_id,
        }
        res = self._session.get(url, headers=self.headers, params=payload)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def job_delete(self, job_id):
        """Delete a job.

        Args:
            job_id: Program job ID.

        Returns:
            Job logs.
        """
        url = self.get_url("job_delete")
        payload = {
            "job_id": job_id,
        }
        res = self._session.get(url, headers=self.headers, params=payload)
        if res.status_code == 200:
            res = res.json()
            return res['status'], res
        else:
            return res.status_code, None

    def get_url(self, identifier: str) -> str:
        """Return the resolved URL for the specified identifier.

        Args:
            identifier: Internal identifier of the endpoint.

        Returns:
            The resolved URL of the endpoint (relative to the session base URL).
        """
        #if '_wait' in identifier:
        #    return self._socket_url
        return "{}{}{}".format(self._url, "/", identifier)
